\documentclass[runningheads]{llncs}
\usepackage{graphicx}
\usepackage{lipsum}
\usepackage{amsmath}

\newcommand{\code}{\texttt}

\begin{document}

\chapter{[Chapter 3] Implementation}

\section{Repository Overview}

[Figure of repository structure]

[Figure of modules interaction]

[Figures] describes the structure of the repository. The main engine is put in the engine directory, being self-supportive on its own with encapsulated APIs for setting up experiments. The engine part is fully written in C++, and has its own structure, which will be described in [section XXX]. The rendering part is isolated from the main engine because it mainly uses third-party rendering library - Blender, to render the results provided by the APIs of the physics engine. However, the rendered videos were what I heavily relied on when testing and evaluating the engine. They will be described in [section XXX]. The report directory is for storing writeup files for the project.

\section{Engine}

As a reminder, the physics engine mainly involves first modelling objects as rigid bodies, then uses a collision detection-resolution feedback loop for simulation. In the repository, these core mechanics are in the core directory. I used a geometry directory to provide utilities for computational geometry. The core directory includes 

\subsection{Geometry}

For better customizability I implemented my own geometry modules. Since the whole engine operates in 3D in every way, I could use just two classes, \code{Vector} and \code{Matrix}, in order to represent $3 \times 1$ and $3 \times 3$ tensors respectively. Some common operators are also supported for quick C++ style syntax. Some of the interfaces include

\begin{itemize}
\item \code{static Matrix star(const Vector\& v)}: the star operation that creates a matrix $A=a^*$ for any vector $a$ such that $A \cdot b = a\times b$.
\item \code{Matrix inverse()}: finding the inverse of a matrix
\item \code{Vector operator*(Vector rhs)}: multiplying matrices with vectors
\end{itemize}

\subsection{Rigid body}

The main class for individual rigid bodies is \code{RigidBody}, with each instance of it representing one unique rigid body. The states and auxilaries are also individually classed as \code{RigidBodyState} and \code{RigidBodyAuxilaries} respectively.

For each rigid body, the main fixed properties are its \code{mass} and \code{bodySpaceInertiaTensor}. \code{CuboidRigidBody} subclasses from \code{RigidBody}, and instead uses \code{length}, \code{width}, and \code{height} to automatically calculate the integral. The subclasses are also responsible for documenting shapes information when outputting.

All the derivatives and computable auxilaries are encapsulated as privated methods like \code{RigidBodyState computeDerivative(RigidBodyState state, RigidBodyForceAndTorque forceAndTorque)}.

\subsection{dy/dx Solver}



\subsection{Collision Detection}

\subsection{Collision Resolution}

\section{Render}


TBA

\noindent\rule{12cm}{0.4pt}

TODO:

citations

content filling

figures

*World space* refers to the main space where physics is simulated. For particles, their *states* can be simply described as its location, or more precisely, by a 3-element vector inscribing their coordinates in the three axis. A rigid body however may be rotated in addition to translation, which would require an additional 3x3 matrix, $R$, in its state. For a rigid body, we consider its *center of mass* (will elaborate later) as the centre, and different locations on the rigid body can be described with the *body space* locations relative to the centre. Let's call the body space location $loc_{body}$ and the world space location $loc_{world}$, then we can imagine the point being rotated around the centre of mass (at location $loc_{centre}$) using rotation matrix $R$ as the equation


This chapter should describe what was actually produced: the programs which were written, the hardware which was built or the theory which was developed. Any design strategies that looked ahead to the testing stage should be described in order to demonstrate a professional approach was taken.

Descriptions of programs may include fragments of high-level code but large chunks of code are usually best left to appendices or omitted altogether. Analogous advice applies to circuit diagrams or detailed steps in a machine-checked proof.

The implementation chapter should include a section labelled "Repository Overview". The repository overview should be around one page in length and should describe the high-level structure of the source code found in your source code repository. It should describe whether the code was written from scratch or if it built on an existing project or tutorial. Making effective use of powerful tools and pre-existing code is often laudable, and will count to your credit if properly reported. Nevertheless, as in the rest of the dissertation, it is essential to draw attention to the parts of the work which are not your own. 

It should not be necessary to give a day-by-day account of the progress of the work but major milestones may sometimes be highlighted with advantage.

$loc_{world} = R \times loc_{body} + loc_{centre}$

\end{document}
